
 ####  go test  
 – это мощный инструмент, встроенный в Go, предназначенный для автоматизированного тестирования кода. Он позволяет разработчикам легко создавать и запускать юнит-тесты, интеграционные тесты и другие виды проверок.
**Как это работает?**
 * Поиск тестовых файлов: Команда ищет файлы с суффиксом `_test.go` в указанном пакете и его подпакетах.
 * Выполнение тестовых функций: Внутри этих файлов она выполняет функции, начинающиеся с Test.
 * Проверка результатов: Если тест завершился неудачно, go test выводит подробное сообщение об ошибке.
**Основные опции:**
 * `-v`: Включает подробный вывод о прохождении каждого теста. Это полезно для отладки и анализа результатов.
 * `go test ./...` - рекурсивно прогнать все тесты
 * `-race` - включить проверку  на предмет состояния гонки
 * `timeout` - установить таймаут для тестов 
	```bash
	go test -timeout 30s
	```
 * `-run`: Выполняет только тесты, соответствующие заданному регулярному выражению. Это позволяет фокусироваться на конкретных тестах.
 ```shell
 go.exe test -benchmem -run=^$ -bench ^BenchmarkFibIterative$
```
 * `-cover`: Включает покрытие кода. Эта опция позволяет узнать, какие части кода были покрыты тестами, а какие нет.
 * `-coverprofile`: Указывает файл, в который будет сохранен профиль покрытия кода. Этот профиль можно визуализировать с помощью go tool cover.
  **Пример использования:**
```shell
go test -v -coverprofile=coverage.txt ./mypackage
```
Эта команда выполнит все тесты в пакете mypackage, включит подробный вывод и сохранит профиль покрытия кода в файл coverage.txt.
 * ` -cpu`: Позволяет запускать тесты с разным количеством логических процессоров
 **Пример использования:**
```shell
go test -cpu=4,5
```
Этот пример запустит тесты дважды: 
 - С четырьмя логическими процессорами.
 - Затем с пятью.

- -bench - проведение бенчмарка
	- `go test -bench . `- бенчмарк всех функций пакета
	- `go test -bench=BenchFuncNme` - выполнение бенча по определенной функции
	-  `go test -bench . -benchmem` - +тестирование потребления памяти
	
**Структура тестового файла:**
та же, что и у тестируемого кода.
 * Функции: Начинаются с Test, например TestMyFunction.
 * Аргументы: Принимают указатель на *testing.T, который используется для записи результатов теста.
**Пример тестовой функции:**
```go
package mypackage_test

import (
        "testing"
        "mypackage"
)

func TestMyFunction(t *testing.T) {
        result := mypackage.MyFunction(42)
        if result != 43 {
                t.Errorf("MyFunction(42) = %d; want 43", result)
        }
}
```

**Визуализация покрытия кода:**
```bash
go tool cover -html=coverage.txt
```
Эта команда откроет отчет о покрытии кода в браузере, что позволяет легко увидеть, какие части кода были покрыты тестами.
**Дополнительные возможности:**
 * Параллельное выполнение тестов: go test может параллельно выполнять тесты, что ускоряет процесс тестирования.
 * Тестирование табличными данными: Можно использовать таблицы для организации тестовых данных и проверки различных сценариев.
 * Моки: Для изоляции тестируемого кода от внешних зависимостей используются моки.
 * Бенчмарки: Для измерения производительности кода используются бенчмарки.
Почему тестирование важно?
 * Уверенность в качестве кода: Тесты помогают гарантировать, что код работает так, как ожидается.
 * Раннее обнаружение ошибок: Ошибки выявляются на ранних этапах разработки, что снижает стоимость исправления.
 * Рефакторинг: Тесты позволяют безопасно изменять код, не боясь нарушить существующую функциональность.
 * Документация: Тесты служат документацией, демонстрируя, как использовать код.


#### Пример

- Предвставлены функции, требующие бенчмарка:
```go 
func FibRecursive(n uint) uint {
    if n <= 2 {
        return 1
    }
    return FibRecursive(n-1) + FibRecursive(n-2)
}

  
func FibIterative(n uint) uint {
    if n <= 2 {
        return 1
    }

    sl := make([]uint, n)
    sl[0] = 1
    sl[1] = 1

  

    var i, res uint
    for i = 2; i < n; i++ {
        res = sl[i-1] + sl[i-2]
        sl[i] = res
    }

    return res
}
```

- приведены примеров функций для тестирования   `FibRecursive` и `FibIterative`
```go
package utils

import (
    "testing"
)

  

func TestFibRecursive(t *testing.T) {
    tests := []struct {
        input    uint
        expected uint
    }{
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
    }

  

    for _, test := range tests {
        if got := FibRecursive(test.input); got != test.expected {
            t.Errorf("FibRecursive(%d) = %d; want %d", test.input, got, test.expected)
        }
    }
}

func BenchmarkFibRecursive(b *testing.B) {
    data := []uint{
        10,
        12,
        15,
        20,
        40,
    }

    for _, j := range data {
        for i := 0; i < b.N; i++ {
            FibRecursive(uint(j))
        }
    }
}

func TestFibIterative(t *testing.T) {
    tests := []struct {
        input    uint
        expected uint
    }{
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
    }

    for _, test := range tests {
        if got := FibIterative(test.input); got != test.expected {
            t.Errorf("FibIterative(%d) = %d; want %d", test.input, got, test.expected)
        }
    }
}

  

func BenchmarkFibIterative(b *testing.B) {

    data := []uint{
        10,
        12,
        15,
        20,
        40,
    }

    for _, j := range data {
        for i := 0; i < b.N; i++ {
            FibIterative(uint(j))
        }
    }
}
```