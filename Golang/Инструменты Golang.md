
### go run
Компилирует и сразу запускает одну или несколько Go программ.
Команда создает временный исполняемый файл, запускает его, а затем удаляет. Отлично подходит для быстрой проверки небольших программ или скриптов. 
**Ключевое отличие от `go build`**: `go run` — это "компилировать и запустить", в то время как `go build` только "компилирует".
```go
go run main.go
```

### go build
Компилирует пакеты и их зависимости.
- Если вы находитесь в директории `main` пакета (где есть функция `main()`), `go build` создаст исполняемый файл в текущей директории. Имя файла по умолчанию — имя директории (или имя .go файла, если указан).
- Если это не `main` пакет, `go build` скомпилирует пакет, но не создаст исполняемый файл (результат компиляции кэшируется).


### go install
Компилирует и устанавливает пакеты и зависимости.
Похоже на `go build`, но исполняемые файлы помещаются в директорию `$GOPATH/bin` (или `$GOBIN`, если установлена). Библиотеки устанавливаются в `$GOPATH/pkg`. Это делает команды доступными из любого места, если `$GOPATH/bin` добавлен в `PATH` вашей системы.


### go mod
Управление  зависимостями

#### go mod init  <module_path>
Инициализирует новый модуль в текущей директории. 
Создает файл `go.mod`. `module_path` обычно соответствует URL вашего репозитория
```go
go mod init github.com/myuser/myproject
```

#### go mod tidy
"Приводит в порядок" зависимости.
Удаляет неиспользуемые зависимости из `go.mod` и `go.sum` и добавляет недостающие, которые используются в коде. Это команда, которую вы будете использовать часто.
```go
go mod tidy
```

#### go mod download
Загружает зависимости, перечисленные в `go.mod`, в локальный кэш модулей. Полезна для предварительной загрузки зависимостей, например, в CI/CD системах.

#### go mod vendor
Создает директорию `vendor` в вашем проекте и копирует туда все зависимости.
озволяет проекту иметь локальную копию всех зависимостей. Сборка с флагом `-mod=vendor` будет использовать пакеты из этой директории.
```go
go mod vendor 
go build -mod=vendorf
```

#### go mod why \<path\>
Объясняет, почему определенный пакет включен в зависимости.
```go
go mod why golang.org/x/text
```

#### go mod graph
Показывает граф зависимостей модуля в текстовом формате.

### go get
В режиме модулей `go get` используется для изменения версий зависимостей в вашем `go.mod` или для добавления новых.
`go get example.com/pkg`: Добавит последнюю версию пакета.
`go get example.com/pkg@v1.2.3`: Добавит или обновит пакет до конкретной версии.
`go get -u example.com/pkg`: Обновит пакет до последней минорной или патч-версии.
`go get -u=patch example.com/pkg`: Обновит пакет до последней патч-версии.

Раньше (до Go Modules) `go get` был основным способом загрузки пакетов. Сейчас его роль несколько изменилась, и для повседневной работы с зависимостями часто достаточно `go mod tidy`.

### go fmt
Автоматически форматирует Go код согласно стандартным правилам Go.
```bash
# Форматировать текущую директорию 
go fmt ./... 

# Форматировать конкретный файл 
go fmt main.go
```


### go vet
Анализирует исходный код Go и сообщает о подозрительных конструкциях, которые могут быть ошибками, но не нарушают синтаксис (например, неправильное использование `Printf` аргументов).
Не гарантирует отсутствие ошибок, но помогает выявить распространенные проблемы.
```bash
go vet ./...
```

##### Внешние линтеры (например, `golangci-lint`)
- Хотя `go vet` полезен, сообщество Go часто использует более мощные инструменты статического анализа, такие как `golangci-lint`. Он объединяет множество линтеров и предоставляет гибкую конфигурацию.
- **Установка (пример)**: `go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest`
- **Использование**: `golangci-lint run`


### go test
Запускает тесты.
Ищет файлы с суффиксом `_test.go` и запускает функции, начинающиеся с `Test` (для юнит-тестов), `Benchmark` (для бенчмарков) или `Example` (для примеров).
```bash
# Запустить все тесты в текущем пакете 
go test 

# Запустить тесты во всех пакетах текущего модуля 
go test ./... 

# Запустить тесты с подробным выводом 
go test -v 

# Запустить конкретный тест по имени (регулярное выражение) 
go test -run TestMyFunction 

# Запустить бенчмарки 
go test -bench . 

# Показать покрытие кода тестами 
go test -cover 
go test -coverprofile=coverage.out && go tool cover -html=coverage.out # Сгенерировать HTML отчет
```


### go doc
Отображает документацию для пакета или символа (функции, переменной и т.д.).
Извлекает комментарии к коду.

```bash
# Документация для пакета 
fmt go doc fmt 

# Документация для функции Println в пакете fmt 
go doc fmt.Println
```


### godoc \<веб-сервер\>
Запускает локальный веб-сервер, который предоставляет документацию в браузере, аналогично pkg.go.dev.
```bash
# Установка (если еще не установлен)
# go get golang.org/x/tools/cmd/godoc (может измениться, проверяйте актуальную команду)
# или go install golang.org/x/tools/cmd/godoc@latest

# Запуск
godoc -http=:6060
```
Затем откройте `http://localhost:6060` в браузере.

### go list
Выводит информацию о пакетах или модулях в различных форматах.
```bash
# Показать все пакеты в текущем модуле
go list ./...

# Показать путь импорта и зависимости пакета fmt
go list -f '{{.ImportPath}} {{.Deps}}' fmt
```

### go env
Выводит информацию о переменных окружения Go.
```go
go env
go env GOROOT # Показать значение конкретной переменной
```

### go version
Показывает текущую версию Go.


### go work
Появился в Go 1.18, позволяет работать с несколькими модулями одновременно, не требуя изменения их `go.mod` файлов для указания локальных путей. Создает файл `go.work`.
```bash
go work init ./module1 ./module2
go work use ./module3 # Добавить еще один модуль
```


### Delve отладка
Хотя Go не включает отладчик в стандартный набор команд `go ...`, **Delve** является де-факто стандартом для отладки Go программ.
Установка
```bash
go install github.com/go-delve/delve/cmd/dlv@latest
```

