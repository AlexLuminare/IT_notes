### Что это такое?
**Каналы** в Go представляют собой тип данных, позволяющий горутинам безопасно обмениваться значениями. Они являются одним из ключевых механизмов для достижения параллелизма и конкурентности в Go, следовательно, они полностью потокобезопасны 

#### Аксиомы каналов

|                       | Чтение                                                                       | Запись                                                                       | Закрытие                       |
| :-------------------- | ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ------------------------------ |
| nil-канал             | вечная блокировка                                                            | вечная блокировка                                                            | паника: close of nil channel   |
| открытый небуф. канал | канал блокируется, пока  в канал не пройдет запись                           | блокируется, пока из  канала не пройдет чтение                               | закрывается                    |
| открытый буф. канал   | канал возвращает данные без блокировки, пока буфер не пуст. Иначе блокировка | канал принимает данные без блокировки, пока буфер не полон. Иначе блокировка | закрывается                    |
| Закрытый канал        | возвр. nil-значение                                                          | panic: send on closed channel                                                | panic: close of closed channel |
#### Инициализация каналов
```go
// Создание nil-канала
var ch chan int

// Создание небуферизированного канала для передачи целых чисел
ch := make(chan int)

// Создание буферизированного канала для передачи строк с емкостью 10
ch := make(chan string, 10)
```

- **Небуферизированный канал:** Отправка значения в такой канал блокирует отправителя до тех пор, пока не найдется горутина, готовая принять это значение. То же самое касается получения значения из канала: получатель будет блокироваться до тех пор, пока в канал не будет отправлено значение.
- **Буферизированный канал:** Имеет ограниченный внутренний буфер. Отправитель может отправить значение в канал без блокировки, даже если в данный момент нет готового получателя, пока буфер не заполнится. Получатель может получить значение из канала, даже если в данный момент нет готового отправителя, пока в буфере есть значения.

#### Работа с каналами
- **Отправка значения:**
    ```go
    ch <- value
    ```

- **Получение значения:**
    ```go    
    value <- ch
    ```
    
- **Закрытие канала:**
    ```go
    close(ch)
    ```
	- После закрытия канала нельзя отправлять в него новые значения, иначе - паника!!!!
	- Чтение из закрытого канала является неблокирующим. Сначала возвращаются данные из буфера канала (если таковой имеется). Если буфер исчерпан - возвращаются zero-значения.

- **Сделать канал ниловым**
```go
ch := make(chan int)
ch = nil
```


#### Использование nil-каналов
Nil-канал в Go (канал со значением `nil`) является полезным инструментом для управления горутинами и логикой в `select` стейтментах. Основное его предназначение — **блокировка операций чтения и записи**.

Когда канал равен `nil`, любая попытка отправить в него данные, получить из него данные или закрыть его приведет к **вечной блокировке** горутины. Это свойство делает его идеальным для временного "отключения" одного из `case` в `select`.


При слиянии нескольких каналов в один, когда один из входных каналов закрывается, его можно установить в `nil`, чтобы `select` больше не пытался из него читать и не вызывал панику при чтении из закрытого канала.

```go
func merge(ch1, ch2 <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for ch1 != nil || ch2 != nil {
			select {
			case val, ok := <-ch1:
				if !ok {
					ch1 = nil // Канал закрыт, отключаем его
					continue
				}
				out <- val
			case val, ok := <-ch2:
				if !ok {
					ch2 = nil // Канал закрыт, отключаем его
					continue
				}
				out <- val
			}
		}
	}()
	return out
}
```

Здесь, как только чтение из канала `ch1` или `ch2` показывает, что он закрыт (`ok == false`), соответствующая переменная канала устанавливается в `nil`. В следующих итерациях цикла `select` будет игнорировать этот `case`. Цикл завершится, когда оба канала станут `nil`.


### Примеры использования каналов
#### Каналы как мьютексы

```go
func ChanAsMutex(){
	var counter := 0
	mutexChan := make(chan strunc{}, 1)
	wg := sync.WaitGroup()
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(){
			defer wg.Done()
			mutexChan <- strunc{}{} //ставим блокировку
			counter++
			<-mutesChan //снимаем группировку
		}()
	}
	wg.Wait()
	fmt.Println(counter)
}
```

#### Каналы как промисы
```go
func makeRequest(num int) <-chan string {
	responseChan := make(chan string)

	go func() {
		time.Sleep(time.Second)
		responseChan <- fmt.Sprintf("response number %d", num)
	}()
	return responseChan
}

func chanAsPromise() {
	firstResponseChan := makeRequest(1)
	secondResponseChan := makeRequest(2)
	// do something else
	fmt.Println("non blocking")

	fmt.Println(<-firstResponseChan, <-secondResponseChan)
}
```

