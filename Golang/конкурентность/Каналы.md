
**Каналы** в Go представляют собой тип данных, позволяющий горутинам безопасно обмениваться значениями. Они являются одним из ключевых механизмов для достижения параллелизма и конкурентности в Go.

### Инициализация каналов
```go
// Создание небуферизированного канала для передачи целых чисел
ch := make(chan int)

// Создание буферизированного канала для передачи строк с емкостью 10
ch := make(chan string, 10)
```

- **Небуферизированный канал:** Отправка значения в такой канал блокирует отправителя до тех пор, пока не найдется горутина, готовая принять это значение. То же самое касается получения значения из канала: получатель будет блокироваться до тех пор, пока в канал не будет отправлено значение.
- **Буферизированный канал:** Имеет ограниченный внутренний буфер. Отправитель может отправить значение в канал без блокировки, даже если в данный момент нет готового получателя, пока буфер не заполнится. Получатель может получить значение из канала, даже если в данный момент нет готового отправителя, пока в буфере есть значения.

### Работа с каналами

- **Отправка значения:**
    ```go
    ch<- value
    ```
    
- **Получение значения:**
    ```go
    value := <-ch
    ```
    
- **Закрытие канала:**
    ```go
    close(ch)
    ```
    
- После закрытия канала нельзя отправлять в него новые значения, иначе - паника!!!!
- Чтение из закрытого канала является неблокирующим. Сначала возвращаются данные из буфера канала (если таковой имеется). Если буфер исчерпан - возвращаются zero-значения.

### Каналы как мьютексы

```go
func ChanAsMutex(){
	var counter := 0
	mutexChan := make(chan strunc{}, 1)
	wg := sync.WaitGroup()
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(){
			defer wg.Done()
			mutexChan <- strunc{}{} //ставим блокировку
			counter++
			<-mutesChan //снимаем группировку
		}()
	}
	wg.Wait()
	fmt.Println(counter)
}
```


### Каналы как промисы
```go
func makeRequest(num int) <-chan string {
	responseChan := make(chan string)

	go func() {
		time.Sleep(time.Second)
		responseChan <- fmt.Sprintf("response number %d", num)
	}()
	return responseChan
}

func chanAsPromise() {
	firstResponseChan := makeRequest(1)
	secondResponseChan := makeRequest(2)
	// do something else
	fmt.Println("non blocking")

	fmt.Println(<-firstResponseChan, <-secondResponseChan)
}
```