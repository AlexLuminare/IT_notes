```go
package main

import "fmt"

func mergeSort(arr []int) []int {
        if len(arr) <= 1 {
                return arr
        }

        mid := len(arr) / 2
        left := mergeSort(arr[:mid])
        right := mergeSort(arr[mid:])

        return merge(left, right)
}

func merge(left, right []int) []int {
        result := make([]int, 0, len(left)+len(right))
        i, j := 0, 0
        for i < len(left) && j < len(right) {
                if left[i] <= right[j] {
                        result = append(result, left[i])
                        i++
                } else {
                        result = append(result, right[j])
                        j++
                }
        }
        result = append(result, left[i:]...)
        result = append(result, right[j:]...)
        return result
}

func main() {
        arr := []int{5, 2, 9, 1, 5, 6}
        sortedArr := mergeSort(arr)
        fmt.Println(sortedArr)
}
```

### Асимптотическая сложность

- **Лучший случай:** O(n log n)
- **Средний случай:** O(n log n)
- **Худший случай:** O(n log n)

Независимо от исходного порядка элементов, сортировка слиянием всегда имеет временную сложность O(n log n). Это делает ее очень эффективным алгоритмом для больших массивов данных.

### Почему сортировка слиянием эффективна?

- **Гарантированная сложность:** Независимость от исходного порядка элементов делает алгоритм предсказуемым по времени выполнения.
- **Стабильная сортировка:** Равные элементы сохраняют свой относительный порядок в отсортированном массиве.
- **Параллелизм:** Алгоритм легко поддается параллельной реализации, что позволяет эффективно использовать многоядерные процессоры.

### Когда использовать сортировку слиянием?

- **Большие массивы данных:** Алгоритм хорошо масштабируется на больших наборах данных.
- **Стабильность сортировки:** Когда важно сохранить относительный порядок равных элементов.
- **Параллельные вычисления:** При необходимости использовать многопоточность или распределенные вычисления.

### Важные моменты

- **Дополнительная память:** Сортировка слиянием требует дополнительной памяти для хранения промежуточных результатов, что может быть недостатком для ограниченных систем.
- **Рекурсия:** Использование рекурсии может привести к переполнению стека при очень больших массивах.