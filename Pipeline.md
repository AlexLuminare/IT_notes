
Паттерн **pipeline** (конвейер) в конкурентном программировании представляет собой цепочку последовательно соединенных этапов обработки данных. Каждый этап (stage) в конвейере выполняется одной или несколькими горутинами. Данные проходят через конвейер, обрабатываясь на каждом этапе и передаваясь на следующий. Этот паттерн особенно полезен для обработки больших объемов данных, где каждый шаг обработки может быть выполнен независимо и потенциально параллельно.


**Основные характеристики паттерна pipeline:**

- **Этапы (Stages):** Конвейер состоит из нескольких этапов обработки. Каждый этап выполняет определенную задачу над входящими данными.
- **Каналы (Channels):** Данные передаются между этапами конвейера через каналы Go. Выход одного этапа служит входом для следующего.
- **Параллелизм:** Каждый этап может выполняться параллельно с другими этапами, что позволяет повысить общую производительность обработки данных.
- **Направленность каналов:** Обычно используются направленные каналы (`<-chan` для входных и `chan<-` для выходных) для четкого определения потока данных и предотвращения случайных операций записи или чтения из неправильного конца канала.
- **Закрытие каналов:** Каждый этап, который отправляет данные в следующий этап, должен закрыть свой выходной канал после того, как все данные будут обработаны и отправлены. Это сигнализирует принимающему этапу об отсутствии новых данных и позволяет ему корректно завершить свою работу (например, через цикл `for range`).


**Пример реализации паттерна pipeline на Golang:**

Предположим, у нас есть задача обработать список строк:

1. **Этап 1 (generator):** Генерирует последовательность строк.
2. **Этап 2 (toUpper):** Преобразует каждую строку в верхний регистр.
3. **Этап 3 (filter):** Фильтрует строки, оставляя только те, которые содержат определенную подстроку.
4. **Этап 4 (printer):** Печатает отфильтрованные строки.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// generator генерирует последовательность строк и отправляет их в выходной канал.
func generator(strings []string) <-chan string {
	out := make(chan string)
	go func() {
		defer close(out) // Закрываем выходной канал после отправки всех строк
		for _, s := range strings {
			fmt.Printf("generator отправляет: %s\n", s)
			out <- s
			time.Sleep(time.Millisecond * 100) // Имитация работы
		}
	}()
	return out
}

// toUpper получает строки из входного канала, преобразует их в верхний регистр
// и отправляет в выходной канал.
func toUpper(in <-chan string) <-chan string {
	out := make(chan string)
	go func() {
		defer close(out) // Закрываем выходной канал после обработки всех строк
		for s := range in {
			upperS := fmt.Sprintf("%s (UPPER)", s)
			fmt.Printf("toUpper обработал: %s -> %s\n", s, upperS)
			out <- upperS
			time.Sleep(time.Millisecond * 150) // Имитация работы
		}
	}()
	return out
}

// filter получает строки из входного канала и отправляет в выходной канал
// только те строки, которые содержат подстроку "go".
func filter(in <-chan string) <-chan string {
	out := make(chan string)
	go func() {
		defer close(out) // Закрываем выходной канал после фильтрации всех строк
		for s := range in {
			if containsGo(s) {
				fmt.Printf("filter пропустил: %s\n", s)
				out <- s
				time.Sleep(time.Millisecond * 200) // Имитация работы
			} else {
				fmt.Printf("filter отфильтровал: %s\n", s)
			}
		}
	}()
	return out
}

// containsGo проверяет, содержит ли строка подстроку "go".
func containsGo(s string) bool {
	for i := 0; i < len(s)-1; i++ {
		if s[i:i+2] == "go" {
			return true
		}
	}
	return false
}

// printer получает строки из входного канала и печатает их.
func printer(in <-chan string, wg *sync.WaitGroup) {
	defer wg.Done()
	for s := range in {
		fmt.Printf("printer получил: %s\n", s)
		time.Sleep(time.Millisecond * 100) // Имитация работы
	}
	fmt.Println("printer завершил работу.")
}

func main() {
	strings := []string{"hello world", "golang is fun", "go routines", "concurrent programming", "no go here"}

	// Создаем этапы конвейера, соединяя их каналами.
	generated := generator(strings)
	upperCase := toUpper(generated)
	filtered := filter(upperCase)

	var wg sync.WaitGroup
	wg.Add(1)
	// Запускаем последний этап (printer) в отдельной горутине.
	go printer(filtered, &wg)

	// Ожидаем завершения работы последнего этапа.
	wg.Wait()

	fmt.Println("Конвейер завершил работу.")
}
```